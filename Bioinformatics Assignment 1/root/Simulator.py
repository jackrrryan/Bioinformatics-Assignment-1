'''
Created on Sep 19, 2014

@author: Jack Ryan B00321033
'''

from random import randint

file = open('Assnt1_sampleinput.fna.txt', 'r')  #opening the FASTA file
template = file.read()  #reading the FASTA file to a string

#some variables used in all calculations
nucleotides = ['A','T','C','G']
antinucleotides = ['T','A','G','C']
preamble = template[0:72]   #This is all the text before the start of the sequence
template = template[73:]    #This is the actual sequence

print("Welcome to the Genome Sequencer 5000!")

sequenceType = askType()

errors = askErrors(sequenceType)

coverage = askCoverage(sequenceType)

print('Sequencing has begun!')

def readSizePosition(sequenceType):
    if sequenceType == 1:
        start = randint(0,9300) #read must end before last bp in sequence
        finish = start+700  #700bp is length of pyrosequencing reads
    elif sequenceType == 2:
        readLength = randint(50,300)    #Illumina can have reads between 50-300 bp
        start = randint(0,(10000-readLength))
        finish = start+readLength
    else:
        readLength = randint(400,900)   #Sanger can have reads between 400-900 bp
        start = randint(0,(10000-readLength))
        finish = start+readLength
    return (start,finish)


def sequence(sequenceType, template, preamble, antinucleotides, nucleotides):
    
    reads = open('reads.txt', w)
    reads.write(preamble + '\n\nBegin sequencing:\n\n')

    for i in range(0,100):  # doing 100 reads of the sequence
        antisense = ''
        sfpositions = readSizePosition(sequenceType)
        start = sfpositions[0]    # this is the start position of this specific read
        finish = sfpositions[1]   # this is the end position of this specific read
        for j in range(start,finish):
            templateN = template[j]
            if templateN == 'A':
                antisense = antisense + antinucleotides[0]
            elif templateN == 'T':
                antisense = antisense + antinucleotides[1]
            elif templateN == 'C':
                antisense = antisense + antinucleotides[2]
            else:
                antisense = antisense + antinucleotides[3]
        reads.write('Read' + i + '[' + start + ':' + finish + ']\n' + antisense + '\n\n')

def randsequence(sequenceType, template, preamble, antinucleotides, nucleotides, errors):

    reads = open('reads.txt', w)
    reads.write(preamble + '\n\nBegin sequencing:\n\n')

    for i in range(0,100):  # doing 100 reads of the sequence
        antisense = ''
        sfpositions = readSizePosition(sequenceType)
        start = sfpositions[0]    # this is the start position of this specific read
        finish = sfpositions[1]   # this is the end position of this specific read
        for j in range(start,finish):
            templateN = template[j]
            if templateN == 'A':
                antisense = antisense + antinucleotides[0]
            elif templateN == 'T':
                antisense = antisense + antinucleotides[1]
            elif templateN == 'C':
                antisense = antisense + antinucleotides[2]
            else:
                antisense = antisense + antinucleotides[3]
        reads.write('Read' + i + '[' + start + ':' + finish + ']\n' + antisense + '\n\n')


def askErrors(sequenceType):
    e = ''
    #loop until user gives a proper 'y' or 'n' answer
    while e != 'y' or 'n':
        e = input('\nTurn on random sequencing errors? Y or N:').lower()
        if e == 'y':
            errors = True
            if sequenceType == 1:
                return 1
            elif sequenceType == 2:
                return 2
            else
                return 3
        if e == 'n':
            errors = False
            return 0

def askType():
    ans = 0
    while ans != 1 or 2 or 3:
        ans = input("Which sequencing method would you like to use?\n"
                    "Input 1 for Pyrosequencing, 2 for Illumina, and 3 for Sanger:")
        if ans == 1:
            return 1
        elif ans == 2:
            return 2
        elif ans == 3:
            return 3

def askCoverage(sequenceType):
    '''
    Coverage (C = nL/G) cannot be below the value generated by one read of minimum length for each method:
    0.07 for Pyrosequencing (minimum read length 700, (1)(700)/10000),
    0.0001 for Illumina (Mimimum read length 50, (1)(50)/10000),
    0.04 for Sanger (Minimum read length 400, (1)(400)/10000)
    '''
    coverage = input("What is the coverage of your sequence protocol?"
                    "Coverage (C = nL/G) cannot be below the value generated by one read of minimum length for each method:"
                    "0.07 for Pyrosequencing (minimum read length 700, (1)(700)/10000),"
                    "0.0001 for Illumina (Mimimum read length 50, (1)(50)/10000),"
                    "0.04 for Sanger (Minimum read length 400, (1)(400)/10000)")
    if sequenceType == 1:
        if coverage < 0.07:
            coverage = coverageErrorLoop(0.07)
    elif sequenceType == 2:
        if coverage < 0.0001:
            coverage = coverageErrorLoop(0.0001)
    else:
        if coverage < 0.04:
            coverage = coverageErrorLoop(0.04)
    return coverage

def coverageErrorLoop(min):
    coverage = 0
    while coverage < min:
        coverage = input("Value entered is less than minimum coverage for this sequencing type."
                        "Enter another value:")
    return coverage