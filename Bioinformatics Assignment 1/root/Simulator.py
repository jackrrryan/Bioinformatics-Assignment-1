'''
Created on Sep 19, 2014

@author: Jack Ryan B00321033
'''

from random import randint
import math

file = open('Assnt1_sampleinput.fna.txt', 'r')  #opening the FASTA file
template = file.read()  #reading the FASTA file to a string

#some variables used in all calculations
nucleotides = ['A','T','C','G']
antinucleotides = ['T','A','G','C']
preamble = template[0:72]   #This is all the text before the start of the sequence
template = template[73:]    #This is the actual sequence

def readSizePosition(sequenceType):
    if sequenceType == 1:
        start = randint(0,9300) #read must end before last bp in sequence
        finish = start+700  #700bp is length of pyrosequencing reads
    elif sequenceType == 2:
        readLength = randint(50,300)    #Illumina can have reads between 50-300 bp
        start = randint(0,(10000-readLength))
        finish = start+readLength
    else:
        readLength = randint(400,900)   #Sanger can have reads between 400-900 bp
        start = randint(0,(10000-readLength))
        finish = start+readLength
    return (start,finish)

def sequence(sequenceType, readNum, template, preamble, antinucleotides, nucleotides):
    
    reads = open('reads.txt', 'w')
    reads.write(preamble + '\n\nBegin sequencing:\n\n')

    for i in range(0,readNum):
        antisense = ''
        sfpositions = readSizePosition(sequenceType)
        start = sfpositions[0]    # this is the start position of this specific read
        finish = sfpositions[1]   # this is the end position of this specific read
        for j in range(start,finish):
            templateN = template[j]
            if templateN == 'A':
                antisense = antisense + antinucleotides[0]
            elif templateN == 'T':
                antisense = antisense + antinucleotides[1]
            elif templateN == 'C':
                antisense = antisense + antinucleotides[2]
            else:
                antisense = antisense + antinucleotides[3]
        reads.write('Read' + i + '[' + start + ':' + finish + ']\n' + antisense + '\n\n')

    reads.close()

def randsequence(sequenceType, readNum, template, preamble, antinucleotides, nucleotides):
    if sequenceType == 1:
        errorpercent = 1    #1/1000, or 99.9% for Pyrosequencing
    elif sequenceType == 2:
        errorpercent = 20   #20/1000, or 98% for Illumina
    else:
        errorpercent = 1    #1/1000, or 99.9% for Sanger

    reads = open('reads.txt', 'w')
    reads.write(preamble + '\n\nBegin sequencing:\n\n')

    for i in range(0,readNum):
        antisense = ''
        sfpositions = readSizePosition(sequenceType)
        start = sfpositions[0]    # this is the start position of this specific read
        finish = sfpositions[1]   # this is the end position of this specific read
        for j in range(start,finish):
            templateN = template[j]
            if templateN == 'A':
                antisense = antisense + antinucleotides[0]
            elif templateN == 'T':
                antisense = antisense + antinucleotides[1]
            elif templateN == 'C':
                antisense = antisense + antinucleotides[2]
            else:
                antisense = antisense + antinucleotides[3]
        reads.write('Read' + i + '[' + start + ':' + finish + ']\n' + antisense + '\n\n')

    reads.close()

def askErrors(sequenceType):
    e = ''
    #loop until user gives a proper 'y' or 'n' answer
    while e != 'y' or 'n':
        e = input('\nTurn on random sequencing errors? Y or N:').lower()
        if e == 'y':
            return True
        if e == 'n':
            return False

def askType():
    ans = input("Which sequencing method would you like to use?\n"
                "Input 1 for Pyrosequencing, 2 for Illumina, and 3 for Sanger:")
    return ans

def askCoverage(sequenceType):
    '''
    Coverage (C = nL/G) cannot be below the value generated by one read of minimum length for each method:
    0.07 for Pyrosequencing (minimum read length 700, (1)(700)/10000),
    0.0001 for Illumina (Mimimum read length 50, (1)(50)/10000),
    0.04 for Sanger (Minimum read length 400, (1)(400)/10000)
    '''
    coverage = float(input("What is the coverage of your sequence protocol?\n"
                    "Coverage (C = nL/G) cannot be below the value generated by one read of minimum length for each method:\n"
                    "0.07 for Pyrosequencing (minimum read length 700, (1)(700)/10000),\n"
                    "0.0001 for Illumina (Mimimum read length 50, (1)(50)/10000),\n"
                    "0.04 for Sanger (Minimum read length 400, (1)(400)/10000):"
                    "Read number will be rounded to nearest integer answer:"))
    if sequenceType == 1:
        if coverage < 0.07:
            coverage = coverageErrorLoop(0.07)
            return math.trunc((coverage*10000)/700)   #700 = average read size for Pyrosequencing
    elif sequenceType == 2:
        if coverage < 0.0001:
            coverage = coverageErrorLoop(0.0001)
            return math.trunc((coverage*10000)/175)   #175 = average read size for Illumina
    else:
        if coverage < 0.04:
            coverage = coverageErrorLoop(0.04)
            return math.trunc((coverage*10000)/650)   #650 = average read size for Sanger

def coverageErrorLoop(min):
    coverage = 0
    while coverage < min:
        coverage = float(input("Value entered is less than minimum coverage for this sequencing type."
                        "Enter another value:"))
    return coverage

print("Welcome to the Genome Sequencer 5000!")

sequenceType = askType()

errors = askErrors(sequenceType)

readNum = askCoverage(sequenceType)

print('Sequencing has begun!')

if errors == True:
    randsequence()